
public class NumOf1_43 {

	/*
	 * 思路1：从1数到n，统计每个数1出现的次数，加起来
	 * O(nlgn)
	 */
	public int numOf1From1Ton_1(int n) {
		int count=0;
		for(int i=1;i<=n;i++)
		{
			count+=numOf1(i);
		}
		return count;
	}
	
	//复杂度:O(lgn)
	private int numOf1(int n) {
		int count=0;
		while(n!=0)
		{
			if (n%10==1) {
				count++;
			}
			n=n/10;
		}
		return count;
	}
	
	/*
	 * 思路2：固定某一位为1，其他位可变，计算出该位是1的所有情况的数目(统计的是该位上的1，没有统计其他位上的1）
	 * 同理可得到其他位为1时总个数
	 * 要固定某一位，可以用m=1,10,100,1000,...对n做除，余操作，得到高位、低位部分
	 * 通过举例寻找规律
	 * 以“213053”为例
	 * 将十位固定为1，m=10,a=n/m=21305,b=n%m=3
	 * 符合这样的数：****1*
	 * 000010
	 * 000011
	 * 000012
	 * 。。。
	 * 000019
	 * 000110
	 * 。。。
	 * 213010
	 * 。。。
	 * 213019
	 * 对于十位之前的高位数，总共有0000~2130共2131种情况，
	 * 每种情况对应低位有0~9共10种情况，故总共：2131*100
	 * 也就是共(a/10+1)*m(对应固定的数字为2~9的情况）
	 * 
	 * 当固定的位为1时，如固定3213053的万位，
	 * a=n/10000=321,b=n%10000=3053
	 * **1****
	 * 0010000
	 * 。。。
	 * 0019999
	 * 。。。
	 * 3119999
	 * 3210000
	 * 。。。
	 * 3213053
	 * 万位前的高位从00~31同之前一样，每一种对应0000~9999种可能
	 * 但到32时，低位只能到3053，0000~3053是3054种情况
	 * 一共31*10000+3054
	 * (a/10-1)*m+(b+1)
	 * 
	 * 再看固定的位为0时，213053
	 *a=n/m=2130
	 *b=n%m=53
	 * ***1**
	 * 000100
	 * 。。。
	 * 000199
	 * 001100
	 * 。。。
	 * 212100
	 * 。。。
	 * 212199
	 * 共(212+1)*100
	 *即(a/10)*m
	 */
	
	public int numOf1From1Ton_2(int n) 
	{
		int count=0;
		for(int m=1;m<n;m*=10)
		{
			int a=n/m;
			int b=n%m;
			if (a%10==0) {
				count+=a/10+m;
			}
			else if (a%10==1) {
				count+=(a/10-1)*m+b+1;
			}
			else {
				count+=(a/10+1)*m;
			}
		}
		return count;
	}
}
